-- Source code:

-- -- A "fused" version of bfast that; the creation of "X" and the batched matrix-matrix
-- -- multiplication are kept separate (otherwise performance is awaful), the remaining
-- -- steps up to and including the calculation of "hmax" is fused in one kernel.
-- -- ==
-- --
-- -- compiled input @ data/D1.in.gz
-- -- compiled input @ data/D2.in.gz
-- -- compiled input @ data/D3.in.gz
-- -- compiled input @ data/D4.in.gz
-- -- compiled input @ data/D5.in.gz
-- -- compiled input @ data/D6.in.gz
-- -- compiled input @ data/peru.in.gz
-- -- output @ data/peru.out.gz
-- -- compiled input @ data/africa.in.gz
-- -- output @ data/africa.out.gz
--
-- -- compiled input @ data/sahara.in.gz
-- -- output @ data/sahara.out.gz
--
-- let logplus (x: f32) : f32 =
--   if x > (f32.exp 1)
--   then f32.log x else 1
--
-- let adjustValInds [N] (n : i32) (ns : i32) (Ns : i32) (val_inds : [N]i32) (ind: i32) : i32 =
--     if ind < Ns - ns then (#[unsafe] val_inds[ind+ns]) - n else -1
--
-- let filterPadWithKeys [n] 't
--            (p : (t -> bool))
--            (dummy : t)
--            (arr : [n]t) : ([n](t,i64), i64) =
--   let tfs = map ( -> if p a then 1 else 0) arr
--   let isT = scan (+) 0 tfs
--   let i   = last isT
--   let inds= map2 ( iT -> if p a then iT-1 else -1) arr isT
--   let rs  = scatter (replicate n dummy) inds arr
--   let ks  = scatter (replicate n 0) inds (iota n)
--   in  (zip rs ks, i)
--
-- -- | builds the X matrices; first result dimensions of size 2*k+2
-- let mkX_with_trend [N] (k2p2: i64) (f: f32) (mappingindices: [N]i64): [k2p2][N]f32 =
--   map (\ i ->
--         map (\ind ->
--                 if i == 0 then 1f32
--                 else if i == 1 then r32 <| i32.i64 ind
--                 else let (i', j') = (r32 <| i32.i64 (i / 2), r32 <| i32.i64 ind)
--                      let angle = 2f32 * f32.pi * i' * j' / f
--                      in  if i 