-- Source code:

-- def main [m][n] (xs: [m][n]i64) (is: [m]i64) (is1: [n]i64) : [m][n]i64 =
--   map (\i ->
--     map (\j ->
--       #[unsafe]
--       let k = 5
--       in xs[is[i*k],is1[j+k]]
--       ) (iota n)
--     ) (iota m)

-- IR:

types {

}



entry("main",
      {xs: [][]i64,
       is: []i64,
       is1: []i64},
      {[][]i64})
  entry_main (m_5424 : i64,
              n_5425 : i64,
              xs_5426 : [m_5424][n_5425]i64,
              is_5427 : [m_5424]i64,
              is1_5428 : [n_5425]i64)
  : {[m_5424][n_5425]i64#([2, 3, 4], [0])} = {
  let {nest_size_5633 : i64} =
    mul_nw64(m_5424, n_5425)
  let {segmap_group_size_5634 : i64} =
    get_size(segmap_group_size_5584, group_size)
  let {segmap_usable_groups_5635 : i64} =
    sdiv_up64(nest_size_5633, segmap_group_size_5634)
  let {defunc_0_map_res_5636 : [m_5424][n_5425]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5635; groupsize=segmap_group_size_5634)
    (gtid_5637 < m_5424, gtid_5638 < n_5425) (~phys_tid_5639) : {i64} {
      let {index_primexp_5652 : i64} =
        mul64(5i64, gtid_5637)
      let {tmp_5640 : i64} =
        is_5427[index_primexp_5652]
      let {tmp_5642 : i64} =
        add64(5i64, gtid_5638)
      let {tmp_5643 : i64} =
        is1_5428[tmp_5642]
      let {lifted_lambda_res_5644 : i64} =
        xs_5426[tmp_5640, tmp_5643]
      return {returns lifted_lambda_res_5644}
    }
  in {defunc_0_map_res_5636}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5636 : {
--     (arr) xs_5426 : [0, 1] {
--         (idx) lifted_lambda_res_5644 :
--             0 : dependencies = tmp_5640 -> {gtid_5637 0 tid}
--             1 : dependencies = tmp_5643 -> {gtid_5638 1 tid}
--     }
-- }
