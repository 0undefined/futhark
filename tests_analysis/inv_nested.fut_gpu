-- Source code:

-- def main [n][m] (xss: [n][m]i64) (is: [n]i64) : [n][m]i64 =
--   let k = foldl (+) 0 (map (\i -> i*0) is)
--   let l = map (\i -> i*k) is
--   in
--   map (\_ ->
--     #[unsafe]
--     loop s=xss[0] for i < n
--     do
--       map2 (+) s xss[ l[i]+i ]
--   ) xss

-- IR:

types {

}



entry("main",
      {xss: [][]i64,
       is: []i64},
      {[][]i64})
  entry_main (n_5480 : i64,
              m_5481 : i64,
              xss_5482 : [n_5480][m_5481]i64,
              is_5483 : [n_5480]i64)
  : {[n_5480][m_5481]i64#([2, 3], [0])} = {
  let {tmp_5627 : [m_5481]i64} =
    xss_5482[0i64, 0i64 :+ m_5481 * 1i64]
  let {segmap_group_size_5662 : i64} =
    get_size(segmap_group_size_5653, group_size)
  let {segmap_usable_groups_5663 : i64} =
    sdiv_up_safe64(m_5481, segmap_group_size_5662)
  let {lifted_lambda_res_5628 : [m_5481]i64} =
    loop {s_5630 : [m_5481]i64} = {tmp_5627}
    for i_5629:i64 < n_5480 do {
      let {defunc_0_map_res_5664 : [m_5481]i64} =
        segmap(thread; ; groups=segmap_usable_groups_5663; groupsize=segmap_group_size_5662)
        (gtid_5665 < m_5481) (~phys_tid_5666) : {i64} {
          let {eta_p_5667 : i64} =
            s_5630[gtid_5665]
          let {eta_p_5668 : i64} =
            xss_5482[i_5629, gtid_5665]
          let {defunc_0_f_res_5669 : i64} =
            add64(eta_p_5667, eta_p_5668)
          return {returns defunc_0_f_res_5669}
        }
      in {defunc_0_map_res_5664}
    }
  let {defunc_0_map_res_5625 : [n_5480][m_5481]i64} =
    replicate([n_5480], lifted_lambda_res_5628)
  in {defunc_0_map_res_5625}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5664 : {
--     (arr) xss_5482 : {
--         (idx) eta_p_5668 :
--             0 : dependencies = {i_5629 0 iter}
--             1 : dependencies = {gtid_5665 1 tid}
--     }
-- }
