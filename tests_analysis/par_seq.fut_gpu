-- Source code:

-- def main [n][m] (xss: [n][m]i64) : [n]i64 =
--   map (\xs ->
--     #[unsafe]
--     loop s=0 for i < m
--     do
--       s + xs[i]
--   ) xss

-- IR:

types {

}



entry("main",
      {xss: [][]i64},
      {[]i64})
  entry_main (n_5126 : i64,
              m_5127 : i64,
              xss_5128 : [n_5126][m_5127]i64)
  : {[n_5126]i64#([2], [0])} = {
  let {segmap_group_size_5183 : i64} =
    get_size(segmap_group_size_5171, group_size)
  let {segmap_usable_groups_5184 : i64} =
    sdiv_up64(n_5126, segmap_group_size_5183)
  let {defunc_0_map_res_5185 : [n_5126]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5184; groupsize=segmap_group_size_5183)
    (gtid_5186 < n_5126) (~phys_tid_5187) : {i64} {
      let {lifted_lambda_res_5189 : i64} =
        loop {s_5191 : i64} = {0i64}
        for i_5190:i64 < m_5127 do {
          let {+_rhs_5192 : i64} =
            xss_5128[gtid_5186, i_5190]
          let {loopres_5193 : i64} =
            add64(s_5191, +_rhs_5192)
          in {loopres_5193}
        }
      return {returns lifted_lambda_res_5189}
    }
  in {defunc_0_map_res_5185}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5185 : {
--     (arr) xss_5128 : [0, 1] {
--         (idx) +_rhs_5192 :
--             0 : dependencies = {gtid_5186 0 tid}
--             1 : dependencies = {i_5190 1 iter}
--     }
-- }
