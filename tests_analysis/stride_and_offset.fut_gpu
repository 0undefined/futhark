-- Source code:

-- def main [n][m] (xss: [n][m]i64) : [n]i64 =
--   map (\xs ->
--     #[unsafe]
--     loop s=0 for i < m do
--       s + xs[i*2+3]

-- IR:

types {

}



entry("main",
      {xss: [][]i64},
      {[]i64})
  entry_main (n_5138 : i64,
              m_5139 : i64,
              xss_5140 : [n_5138][m_5139]i64)
  : {[n_5138]i64#([2], [0])} = {
  let {segmap_group_size_5205 : i64} =
    get_size(segmap_group_size_5191, group_size)
  let {segmap_usable_groups_5206 : i64} =
    sdiv_up64(n_5138, segmap_group_size_5205)
  let {defunc_0_map_res_5207 : [n_5138]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5206; groupsize=segmap_group_size_5205)
    (gtid_5208 < n_5138) (~phys_tid_5209) : {i64} {
      let {lifted_lambda_res_5211 : i64} =
        loop {s_5213 : i64} = {0i64}
        for i_5212:i64 < m_5139 do {
          let {+_lhs_5214 : i64} =
            mul64(2i64, i_5212)
          let {+_rhs_5215 : i64} =
            add64(3i64, +_lhs_5214)
          let {+_rhs_5216 : i64} =
            xss_5140[gtid_5208, +_rhs_5215]
          let {loopres_5217 : i64} =
            add64(s_5213, +_rhs_5216)
          in {loopres_5217}
        }
      return {returns lifted_lambda_res_5211}
    }
  in {defunc_0_map_res_5207}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5207 : {
--     (arr) xss_5140 : [0, 1] {
--         (idx) +_rhs_5216 :
--             0 : dependencies = {gtid_5208 0 tid}
--             1 : dependencies = +_rhs_5215 -> {i_5212 1 iter}
--     }
-- }
