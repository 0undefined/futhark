-- Source code:

-- def main [n][m] (xss: [n][m]i64) : [n]i64 =
--   map (\xs ->
--     #[unsafe]
--     loop s=0 for i < m
--     do
--       s + xs[ i*0 ]
--   ) xss

-- IR:

types {

}



entry("main",
      {xss: [][]i64},
      {[]i64})
  entry_main (n_5132 : i64,
              m_5133 : i64,
              xss_5134 : [n_5132][m_5133]i64)
  : {[n_5132]i64#([2], [0])} = {
  let {loop_nonempty_5171 : bool} =
    slt64(0i64, m_5133)
  let {segmap_group_size_5192 : i64} =
    get_size(segmap_group_size_5182, group_size)
  let {segmap_usable_groups_5193 : i64} =
    sdiv_up64(n_5132, segmap_group_size_5192)
  let {defunc_0_map_res_5194 : [n_5132]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5193; groupsize=segmap_group_size_5192)
    (gtid_5195 < n_5132) (~phys_tid_5196) : {i64} {
      let {+_rhs_5198 : i64} =
        if <fallback> loop_nonempty_5171
        then {
          let {x_5199 : i64} =
            xss_5134[gtid_5195, 0i64]
          in {x_5199}
        } else {0i64}
        : {i64}
      let {y_5200 : i64} =
        mul64(m_5133, +_rhs_5198)
      return {returns y_5200}
    }
  in {defunc_0_map_res_5194}
}

-- === Expected output of analysis: CONFIRMED
-- (segmap) defunc_0_map_res_5194 : {
--     (arr) xss_5134 : [0, 1] {
--         (idx) x_5199 :
--             0 : dependencies = {gtid_5195 0 tid}
--             1 : dependencies = {}
--     }
-- }
