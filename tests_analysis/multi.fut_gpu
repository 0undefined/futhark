-- Source code:

-- def main [l][m][n] (xsss: [l][m][n]i64) : [l][m]i64 =
--     map (\i ->
--         map (\j ->
--             #[unsafe]
--             reduce (+) 0 xsss[i+j][i*j]
--         ) (iota m)
--     ) (iota l)

-- IR:

types {

}



entry("main",
      {xsss: [][][]i64},
      {[][]i64})
  entry_main (l_5390 : i64,
              m_5391 : i64,
              n_5392 : i64,
              xsss_5393 : [l_5390][m_5391][n_5392]i64)
  : {[l_5390][m_5391]i64#([3], [0])} = {
  let {suff_outer_par_5562 : bool} =
    cmp_size(suff_outer_par_0, threshold(def, )) <= l_5390
  let {nest_size_5737 : i64} =
    mul_nw64(l_5390, m_5391)
  let {segmap_group_size_5738 : i64} =
    get_size(segmap_group_size_5607, group_size)
  let {suff_outer_par_5742 : bool} =
    cmp_size(suff_outer_par_1, threshold(def, !suff_outer_par_0)) <= nest_size_5737
  let {nest_size_5788 : i64} =
    mul_nw64(n_5392, nest_size_5737)
  let {segred_group_size_5789 : i64} =
    get_size(segred_group_size_5634, group_size)
  let {num_groups_5790 : i64} =
    calc_num_groups(nest_size_5788, segred_num_groups_5636, segred_group_size_5789)
  let {segmap_group_size_5585 : i64} =
    get_size(segmap_group_size_5566, group_size)
  let {num_groups_5586 : i64} =
    calc_num_groups(l_5390, segmap_num_groups_5568, segmap_group_size_5585)
  let {defunc_0_map_res_5560 : [l_5390][m_5391]i64} =
    if <equiv> suff_outer_par_5562
    then {
      let {defunc_0_map_res_5588 : [l_5390][m_5391]i64} =
        segmap(thread; virtualise; groups=num_groups_5586; groupsize=segmap_group_size_5585)
        (gtid_5589 < l_5390) (~phys_tid_5590) : {[m_5391]i64} {
          let {result_5835 : [m_5391]i64} =
            scratch(i64, m_5391)
          let {defunc_0_map_res_5592 : [m_5391]i64} =
            loop {mapout_5836 : *[m_5391]i64} = {result_5835}
            for i_5837:i64 < m_5391 do {
              let {reduce_arg2_5594 : i64} =
                add64(gtid_5589, i_5837)
              let {reduce_arg2_5595 : i64} =
                mul64(gtid_5589, i_5837)
              let {defunc_0_reduce_res_5597 : i64} =
                loop {redout_5839 : i64} = {0i64}
                for i_5840:i64 < n_5392 do {
                  let {x_5601 : i64} =
                    xsss_5393[reduce_arg2_5594, reduce_arg2_5595, i_5840]
                  let {defunc_0_op_res_5600 : i64} =
                    add64(x_5601, redout_5839)
                  in {defunc_0_op_res_5600}
                }
              let {lw_dest_5838 : [m_5391]i64} =
                mapout_5836 with [i_5837] = defunc_0_reduce_res_5597
              in {lw_dest_5838}
            }
          return {returns defunc_0_map_res_5592}
        }
      in {defunc_0_map_res_5588}
    } else {
      let {segmap_usable_groups_5739 : i64} =
        sdiv_up64(nest_size_5737, segmap_group_size_5738)
      let {defunc_0_map_res_5743 : [l_5390][m_5391]i64} =
        if <equiv> suff_outer_par_5742
        then {
          let {defunc_0_map_res_5744 : [l_5390][m_5391]i64} =
            segmap(thread; ; groups=segmap_usable_groups_5739; groupsize=segmap_group_size_5738)
            (gtid_5745 < l_5390, gtid_5746 < m_5391) (~phys_tid_5747) : {i64} {
              let {reduce_arg2_5750 : i64} =
                add64(gtid_5745, gtid_5746)
              let {reduce_arg2_5751 : i64} =
                mul64(gtid_5745, gtid_5746)
              let {defunc_0_reduce_res_5753 : i64} =
                loop {redout_5841 : i64} = {0i64}
                for i_5842:i64 < n_5392 do {
                  let {x_5757 : i64} =
                    xsss_5393[reduce_arg2_5750, reduce_arg2_5751, i_5842]
                  let {defunc_0_op_res_5756 : i64} =
                    add64(x_5757, redout_5841)
                  in {defunc_0_op_res_5756}
                }
              return {returns defunc_0_reduce_res_5753}
            }
          in {defunc_0_map_res_5744}
        } else {
          let {defunc_0_map_res_5792 : [l_5390][m_5391]i64} =
            segred(thread; ; groups=num_groups_5790; groupsize=segred_group_size_5789)
            (gtid_5793 < l_5390, gtid_5794 < m_5391, gtid_5795 < n_5392) (~phys_tid_5796)
            ({0i64},
            ,
            commutative \ {eta_p_5797 : i64,
                           eta_p_5798 : i64}
              : {i64} ->
              let {defunc_0_op_res_5799 : i64} =
                add64(eta_p_5797, eta_p_5798)
              in {defunc_0_op_res_5799})
            : {i64} {
              let {index_primexp_5829 : i64} =
                add64(gtid_5793, gtid_5794)
              let {index_primexp_5834 : i64} =
                mul64(gtid_5793, gtid_5794)
              let {x_5802 : i64} =
                xsss_5393[index_primexp_5829, index_primexp_5834, gtid_5795]
              return {returns x_5802}
            }
          in {defunc_0_map_res_5792}
        }
        : {[l_5390][m_5391]i64}
      in {defunc_0_map_res_5743}
    }
    : {[l_5390][m_5391]i64}
  in {defunc_0_map_res_5560}
}

-- === Expected output of analysis: CONFIRMED
-- (segmap) defunc_0_map_res_5588 : {
--     (arr) xsss_5393 : [0, 1, 2] {
--         (idx) x_5601 :
--             0 : dependencies = reduce_arg2_5594 -> {gtid_5589 0 tid, i_5837 1 iter}
--             1 : dependencies = reduce_arg2_5595 -> {gtid_5589 0 tid, i_5837 1 iter}
--             2 : dependencies = {i_5840 2 iter}
--     }
-- }
-- (segmap) defunc_0_map_res_5744 : {
--     (arr) xsss_5393 : [0, 1, 2] {
--         (idx) x_5757 :
--             0 : dependencies = reduce_arg2_5750 -> {gtid_5745 0 tid, gtid_5746 1 tid}
--             1 : dependencies = reduce_arg2_5751 -> {gtid_5745 0 tid, gtid_5746 1 tid}
--             2 : dependencies = {i_5842 2 iter}
--     }
-- }
-- (segred) defunc_0_map_res_5792 : {
--     (arr) xsss_5393 : [0, 1, 2] {
--         (idx) x_5802 :
--             0 : dependencies = index_primexp_5829 -> {gtid_5793 0 tid, gtid_5794 1 tid}
--             1 : dependencies = index_primexp_5834 -> {gtid_5793 0 tid, gtid_5794 1 tid}
--             2 : dependencies = {gtid_5795 2 tid}
--     }
-- }
