-- Source code:

-- def main (x: i64) (y: i64) : [x]i64 =
--   let b = y + 2 in
--   let rs = tabulate x (\ii ->
--   loop acc = 0 for i < x do
--     let a = b + acc
--     in acc + a + ii / i
--   )
--   in map2 (+) rs <| reverse rs

-- IR:

types {
  
}



entry("main",
      {x: i64,
       y: i64},
      {[]i64})
  entry_main (x_5411 : i64,
              y_5412 : i64)
  : {[x_5411]i64#([], [0])} = {
  let {b_5517 : i64} =
    add64(2i64, y_5412)
  let {bounds_invalid_upwards_5518 : bool} =
    slt64(x_5411, 0i64)
  let {valid_5519 : bool} =
    not bounds_invalid_upwards_5518
  let {range_valid_c_5520 : unit} =
    assert(valid_5519, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", x_5411 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
  let {segmap_group_size_5575 : i64} =
    get_size(segmap_group_size_5558, group_size)
  let {segmap_usable_groups_5576 : i64} =
    sdiv_up64(x_5411, segmap_group_size_5575)
  let {defunc_0_map_res_5577 : [x_5411]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5576; groupsize=segmap_group_size_5575)
    (gtid_5578 < x_5411) (~phys_tid_5579) : {i64} {
      let {lifted_lambda_res_5581 : i64} =
        loop {acc_5583 : i64} = {0i64}
        for i_5582:i64 < x_5411 do {
          let {a_5584 : i64} =
            add64(b_5517, acc_5583)
          let {+_lhs_5585 : i64} =
            add64(acc_5583, a_5584)
          let {zero_5586 : bool} =
            eq_i64(i_5582, 0i64)
          let {nonzero_5587 : bool} =
            not zero_5586
          let {nonzero_cert_5588 : unit} =
            assert(nonzero_5587, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/missing-context.fut:6:21-24")
          let {+_rhs_5589 : i64} =
            #{range_valid_c_5520, nonzero_cert_5588}
            sdiv64(gtid_5578, i_5582)
          let {loopres_5590 : i64} =
            add64(+_lhs_5585, +_rhs_5589)
          in {loopres_5590}
        }
      return {returns lifted_lambda_res_5581}
    }
  let {w_minus_1_5534 : i64} =
    sub64(x_5411, 1i64)
  let {segmap_group_size_5603 : i64} =
    get_size(segmap_group_size_5594, group_size)
  let {segmap_usable_groups_5604 : i64} =
    sdiv_up64(x_5411, segmap_group_size_5603)
  let {defunc_0_map_res_5605 : [x_5411]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5604; groupsize=segmap_group_size_5603)
    (gtid_5606 < x_5411) (~phys_tid_5607) : {i64} {
      let {eta_p_5608 : i64} =
        defunc_0_map_res_5577[gtid_5606]
      let {slice_5612 : i64} =
        sub_nw64(w_minus_1_5534, gtid_5606)
      let {eta_p_5609 : i64} =
        defunc_0_map_res_5577[slice_5612]
      let {defunc_0_f_res_5610 : i64} =
        add64(eta_p_5608, eta_p_5609)
      return {returns defunc_0_f_res_5610}
    }
  in {defunc_0_map_res_5605}
}

-- === Expected output of analysis:

