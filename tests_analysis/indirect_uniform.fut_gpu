-- Source code:

-- def main [m][n] (xs: [m][n]i64) (is: [m]i64) (is1: [n]i64) : [m][n]i64 =
--   map (\i ->
--     map (\j ->
--       #[unsafe] xs[is[i],is1[j]]
--       ) (iota n)
--     ) (iota m)

-- IR:

types {

}



entry("main",
      {xs: [][]i64,
       is: []i64,
       is1: []i64},
      {[][]i64})
  entry_main (m_5411 : i64,
              n_5412 : i64,
              xs_5413 : [m_5411][n_5412]i64,
              is_5414 : [m_5411]i64,
              is1_5415 : [n_5412]i64)
  : {[m_5411][n_5412]i64#([2, 3, 4], [0])} = {
  let {nest_size_5585 : i64} =
    mul_nw64(m_5411, n_5412)
  let {segmap_group_size_5586 : i64} =
    get_size(segmap_group_size_5560, group_size)
  let {segmap_usable_groups_5587 : i64} =
    sdiv_up64(nest_size_5585, segmap_group_size_5586)
  let {defunc_0_map_res_5588 : [m_5411][n_5412]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5587; groupsize=segmap_group_size_5586)
    (gtid_5589 < m_5411, gtid_5590 < n_5412) (~phys_tid_5591) : {i64} {
      let {is_elem_5592 : i64} =
        is_5414[gtid_5589]
      let {is1_elem_5593 : i64} =
        is1_5415[gtid_5590]
      let {lifted_lambda_res_5594 : i64} =
        xs_5413[is_elem_5592, is1_elem_5593]
      return {returns lifted_lambda_res_5594}
    }
  in {defunc_0_map_res_5588}
}

-- === Expected output of analysis: CONFIRMED
-- (segmap) defunc_0_map_res_5588 : {
--     (arr) xs_5413 : [0, 1] {
--         (idx) lifted_lambda_res_5594 :
--             0 : dependencies = is_elem_5592 -> {gtid_5589 0 tid}
--             1 : dependencies = is1_elem_5593 -> {gtid_5590 1 tid}
--     }
-- }
