-- Source code:

-- def main [m][n] (xs: [m][n]i64) (is: [m]i64) (is1: [n]i64) : [m][n]i64 =
--   map (\i ->
--     map (\j ->
--       #[unsafe] xs[is[i+2],is1[j*3]]
--       ) (iota n)
--     ) (iota m)

-- IR:

types {

}



entry("main",
      {xs: [][]i64,
       is: []i64,
       is1: []i64},
      {[][]i64})
  entry_main (m_5423 : i64,
              n_5424 : i64,
              xs_5425 : [m_5423][n_5424]i64,
              is_5426 : [m_5423]i64,
              is1_5427 : [n_5424]i64)
  : {[m_5423][n_5424]i64#([2, 3, 4], [0])} = {
  let {nest_size_5632 : i64} =
    mul_nw64(m_5423, n_5424)
  let {segmap_group_size_5633 : i64} =
    get_size(segmap_group_size_5583, group_size)
  let {segmap_usable_groups_5634 : i64} =
    sdiv_up64(nest_size_5632, segmap_group_size_5633)
  let {defunc_0_map_res_5635 : [m_5423][n_5424]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5634; groupsize=segmap_group_size_5633)
    (gtid_5636 < m_5423, gtid_5637 < n_5424) (~phys_tid_5638) : {i64} {
      let {index_primexp_5651 : i64} =
        add64(2i64, gtid_5636)
      let {tmp_5639 : i64} =
        is_5426[index_primexp_5651]
      let {tmp_5641 : i64} =
        mul64(3i64, gtid_5637)
      let {tmp_5642 : i64} =
        is1_5427[tmp_5641]
      let {lifted_lambda_res_5643 : i64} =
        xs_5425[tmp_5639, tmp_5642]
      return {returns lifted_lambda_res_5643}
    }
  in {defunc_0_map_res_5635}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5635 : {
--     (arr) xs_5425 : [0, 1] {
--         (idx) lifted_lambda_res_5643 :
--             0 : dependencies = tmp_5639 -> {gtid_5636 0 tid}
--             1 : dependencies = tmp_5642 -> {gtid_5637 1 tid}
--     }
-- }
