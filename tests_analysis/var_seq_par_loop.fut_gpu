-- Source code:

-- def main [n][m] (xss: [n][m]i64) : [m]i64 =
--     #[unsafe]
--     loop res=replicate m 0 for i < n
--     do
--         map2 (\x r -> x+r) xss[i] res

-- IR:

types {

}



entry("main",
      {xss: [][]i64},
      {[]i64})
  entry_main (n_5278 : i64,
              m_5279 : i64,
              xss_5280 : [n_5278][m_5279]i64)
  : {[m_5279]i64#([2], [0])} = {
  let {defunc_0_map_res_5323 : [m_5279]i64} =
    replicate([m_5279], 0i64)
  let {segmap_group_size_5348 : i64} =
    get_size(segmap_group_size_5339, group_size)
  let {segmap_usable_groups_5349 : i64} =
    sdiv_up_safe64(m_5279, segmap_group_size_5348)
  let {main_res_5324 : [m_5279]i64} =
    loop {res_5326 : [m_5279]i64} = {defunc_0_map_res_5323}
    for i_5325:i64 < n_5278 do {
      let {defunc_0_map_res_5350 : [m_5279]i64} =
        segmap(thread; ; groups=segmap_usable_groups_5349; groupsize=segmap_group_size_5348)
        (gtid_5351 < m_5279) (~phys_tid_5352) : {i64} {
          let {eta_p_5353 : i64} =
            xss_5280[i_5325, gtid_5351]
          let {eta_p_5354 : i64} =
            res_5326[gtid_5351]
          let {lifted_lambda_res_5355 : i64} =
            add64(eta_p_5353, eta_p_5354)
          return {returns lifted_lambda_res_5355}
        }
      in {defunc_0_map_res_5350}
    }
  in {main_res_5324}
}

-- === Expected output of analysis:
-- (segmap) defunc_0_map_res_5350 : {
--     (arr) xss_5280 : [0, 1] {
--         (idx) eta_p_5353 :
--             0 : dependencies = {i_5325 0 iter}
--             1 : dependencies = {gtid_5351 1 tid}
--     }
-- }
