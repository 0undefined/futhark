types {

}



entry("main",
      {trend: i32,
       k: i32,
       n: i32,
       freq: f32,
       hfrac: f32,
       lam: f32,
       mappingindices: []i32,
       images: [][]f32},
      {[]i32,
       []f32})
  entry_main (N_9435 : i64,
              m_9436 : i64,
              trend_9437 : i32,
              k_9438 : i32,
              n_9439 : i32,
              freq_9440 : f32,
              hfrac_9441 : f32,
              lam_9442 : f32,
              mappingindices_9443 : [N_9435]i32,
              images_9444 : [m_9436][N_9435]f32)
  : {[m_9436]i32#([8, 9], [0, 1]),
     [m_9436]f32#([8, 9], [0, 1])} = {
  let {+_lhs_11014 : i32} =
    mul32(2i32, k_9438)
  let {k2p2_11015 : i32} =
    add32(2i32, +_lhs_11014)
  let {cond_11016 : bool} =
    slt32(0i32, trend_9437)
  let {<|_rhs_f_res_11017 : i32} =
    sub32(k2p2_11015, 1i32)
  let {<|_rhs_11018 : i32} =
    if cond_11016
    then {k2p2_11015} else {<|_rhs_f_res_11017}
    : {i32}
  let {i32_res_11019 : i64} =
    sext i32 <|_rhs_11018 to i64
  let {segmap_group_size_11686 : i64} =
    get_size(segmap_group_size_11678, group_size)
  let {segmap_usable_groups_11687 : i64} =
    sdiv_up64(N_9435, segmap_group_size_11686)
  let {defunc_0_map_res_11688 : [N_9435]i64} =
    segmap(thread; ; groups=segmap_usable_groups_11687; groupsize=segmap_group_size_11686)
    (gtid_11689 < N_9435) (~phys_tid_11690) : {i64} {
      let {eta_p_11691 : i32} =
        mappingindices_9443[gtid_11689]
      let {i32_res_11692 : i64} =
        sext i32 eta_p_11691 to i64
      return {returns i32_res_11692}
    }
  let {i32_res_11023 : i64} =
    sext i32 n_9439 to i64
  let {<|_rhs_11024 : [i32_res_11019][N_9435]f32} =
    if cond_11016
    then {
      let {bounds_invalid_upwards_11605 : bool} =
        slt64(i32_res_11019, 0i64)
      let {valid_11606 : bool} =
        not bounds_invalid_upwards_11605
      let {range_valid_c_11607 : unit} =
        assert(valid_11606, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", i32_res_11019 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
      let {nest_size_11796 : i64} =
        mul_nw64(N_9435, i32_res_11019)
      let {segmap_group_size_11797 : i64} =
        get_size(segmap_group_size_11710, group_size)
      let {segmap_usable_groups_11798 : i64} =
        sdiv_up64(nest_size_11796, segmap_group_size_11797)
      let {defunc_0_map_res_11799 : [i32_res_11019][N_9435]f32} =
        segmap(thread; ; groups=segmap_usable_groups_11798; groupsize=segmap_group_size_11797)
        (gtid_11800 < i32_res_11019, gtid_11801 < N_9435) (~phys_tid_11802) : {f32} {
          let {index_primexp_12774 : bool} =
            eq_i64(gtid_11800, 0i64)
          let {index_primexp_12771 : bool} =
            eq_i64(gtid_11800, 1i64)
          let {cmpop_x_12767 : i64} =
            smod64(gtid_11800, 2i64)
          let {index_primexp_12768 : bool} =
            eq_i64(cmpop_x_12767, 0i64)
          let {convop_x_12761 : i64} =
            sdiv64(gtid_11800, 2i64)
          let {convop_x_12762 : i32} =
            sext i64 convop_x_12761 to i32
          let {binop_y_12763 : f32} =
            sitofp i32 convop_x_12762 to f32
          let {index_primexp_12764 : f32} =
            fmul32(6.2831855f32, binop_y_12763)
          let {lifted_lambda_res_11808 : f32} =
            #{range_valid_c_11607}
            if index_primexp_12774
            then {1.0f32} else {
              let {eta_p_11807 : i64} =
                defunc_0_map_res_11688[gtid_11801]
              let {lifted_lambda_res_f_res_11809 : f32} =
                #{range_valid_c_11607}
                if index_primexp_12771
                then {
                  let {i64_res_11810 : i32} =
                    sext i64 eta_p_11807 to i32
                  let {i32_res_11811 : f32} =
                    sitofp i32 i64_res_11810 to f32
                  in {i32_res_11811}
                } else {
                  let {i64_res_11812 : i32} =
                    sext i64 eta_p_11807 to i32
                  let {i32_res_11813 : f32} =
                    sitofp i32 i64_res_11812 to f32
                  let {/_lhs_11814 : f32} =
                    #{range_valid_c_11607}
                    fmul32(i32_res_11813, index_primexp_12764)
                  let {angle_11815 : f32} =
                    fdiv32(/_lhs_11814, freq_9440)
                  let {lifted_lambda_res_f_res_f_res_11816 : f32} =
                    #{range_valid_c_11607}
                    if index_primexp_12768
                    then {
                      let {sin_res_11817 : f32} =
                        apply sin32(angle_11815)
                        : {f32}
                      in {sin_res_11817}
                    } else {
                      let {cos_res_11818 : f32} =
                        apply cos32(angle_11815)
                        : {f32}
                      in {cos_res_11818}
                    }
                    : {f32}
                  in {lifted_lambda_res_f_res_f_res_11816}
                }
                : {f32}
              in {lifted_lambda_res_f_res_11809}
            }
            : {f32}
          return {returns lifted_lambda_res_11808}
        }
      in {defunc_0_map_res_11799}
    } else {
      let {bounds_invalid_upwards_11314 : bool} =
        slt64(i32_res_11019, 0i64)
      let {valid_11315 : bool} =
        not bounds_invalid_upwards_11314
      let {range_valid_c_11316 : unit} =
        assert(valid_11315, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", i32_res_11019 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
      let {nest_size_11913 : i64} =
        mul_nw64(N_9435, i32_res_11019)
      let {segmap_group_size_11914 : i64} =
        get_size(segmap_group_size_11836, group_size)
      let {segmap_usable_groups_11915 : i64} =
        sdiv_up64(nest_size_11913, segmap_group_size_11914)
      let {defunc_0_map_res_11916 : [i32_res_11019][N_9435]f32} =
        segmap(thread; ; groups=segmap_usable_groups_11915; groupsize=segmap_group_size_11914)
        (gtid_11917 < i32_res_11019, gtid_11918 < N_9435) (~phys_tid_11919) : {f32} {
          let {index_primexp_12789 : bool} =
            eq_i64(gtid_11917, 0i64)
          let {binop_x_12784 : i64} =
            add64(1i64, gtid_11917)
          let {cmpop_x_12785 : i64} =
            smod64(binop_x_12784, 2i64)
          let {index_primexp_12786 : bool} =
            eq_i64(cmpop_x_12785, 0i64)
          let {convop_x_12778 : i64} =
            sdiv64(binop_x_12784, 2i64)
          let {convop_x_12779 : i32} =
            sext i64 convop_x_12778 to i32
          let {binop_y_12780 : f32} =
            sitofp i32 convop_x_12779 to f32
          let {index_primexp_12781 : f32} =
            fmul32(6.2831855f32, binop_y_12780)
          let {lifted_lambda_res_11924 : f32} =
            #{range_valid_c_11316}
            if index_primexp_12789
            then {1.0f32} else {
              let {eta_p_11923 : i64} =
                defunc_0_map_res_11688[gtid_11918]
              let {i64_res_11925 : i32} =
                sext i64 eta_p_11923 to i32
              let {i32_res_11926 : f32} =
                sitofp i32 i64_res_11925 to f32
              let {/_lhs_11927 : f32} =
                #{range_valid_c_11316}
                fmul32(i32_res_11926, index_primexp_12781)
              let {angle_11928 : f32} =
                fdiv32(/_lhs_11927, freq_9440)
              let {lifted_lambda_res_f_res_11929 : f32} =
                #{range_valid_c_11316}
                if index_primexp_12786
                then {
                  let {sin_res_11930 : f32} =
                    apply sin32(angle_11928)
                    : {f32}
                  in {sin_res_11930}
                } else {
                  let {cos_res_11931 : f32} =
                    apply cos32(angle_11928)
                    : {f32}
                  in {cos_res_11931}
                }
                : {f32}
              in {lifted_lambda_res_f_res_11929}
            }
            : {f32}
          return {returns lifted_lambda_res_11924}
        }
      in {defunc_0_map_res_11916}
    }
    : {[i32_res_11019][N_9435]f32}
  let {opaque_res_11070 : [i32_res_11019][N_9435]f32} =
    opaque(<|_rhs_11024)
  let {+_lhs_11071 : i64} =
    mul64(N_9435, N_9435)
  let {+_rhs_11072 : i64} =
    mul64(2i64, N_9435)
  let {+_lhs_11073 : i64} =
    add64(+_lhs_11071, +_rhs_11072)
  let {/_lhs_11074 : i64} =
    add64(1i64, +_lhs_11073)
  let {/_rhs_11075 : i64} =
    add64(1i64, N_9435)
  let {zero_11076 : bool} =
    eq_i64(/_rhs_11075, 0i64)
  let {nonzero_11077 : bool} =
    not zero_11076
  let {nonzero_cert_11078 : unit} =
    assert(nonzero_11077, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:135:48-56")
  let {-_lhs_11079 : i64} =
    #{nonzero_cert_11078}
    sdiv64(/_lhs_11074, /_rhs_11075)
  let {-_lhs_11080 : i64} =
    sub64(-_lhs_11079, N_9435)
  let {<|_rhs_11081 : i64} =
    sub64(-_lhs_11080, 1i64)
  let {i64_res_11082 : i32} =
    sext i64 <|_rhs_11081 to i32
  let {i32_res_11083 : f32} =
    sitofp i32 i64_res_11082 to f32
  let {nest_size_11969 : i64} =
    mul_nw64(N_9435, i32_res_11019)
  let {segmap_group_size_11970 : i64} =
    get_size(segmap_group_size_11946, group_size)
  let {segmap_usable_groups_11971 : i64} =
    sdiv_up64(nest_size_11969, segmap_group_size_11970)
  let {defunc_0_map_res_11972 : [N_9435][i32_res_11019]f32} =
    segmap(thread; ; groups=segmap_usable_groups_11971; groupsize=segmap_group_size_11970)
    (gtid_11973 < N_9435, gtid_11974 < i32_res_11019) (~phys_tid_11975) : {f32} {
      let {eta_p_11976 : f32} =
        opaque_res_11070[gtid_11974, gtid_11973]
      let {lifted_lambda_res_11977 : f32} =
        fadd32(i32_res_11083, eta_p_11976)
      return {returns lifted_lambda_res_11977}
    }
  let {opaque_res_11090 : [N_9435][i32_res_11019]f32} =
    opaque(defunc_0_map_res_11972)
  let {empty_slice_11091 : bool} =
    eq_i64(i32_res_11019, 0i64)
  let {m_11092 : i64} =
    sub64(i32_res_11019, 1i64)
  let {zero_leq_i_p_m_t_s_11093 : bool} =
    sle64(0i64, m_11092)
  let {i_p_m_t_s_leq_w_11094 : bool} =
    slt64(m_11092, i32_res_11019)
  let {y_11095 : bool} =
    logand(zero_leq_i_p_m_t_s_11093, i_p_m_t_s_leq_w_11094)
  let {ok_or_empty_11096 : bool} =
    logor(empty_slice_11091, y_11095)
  let {empty_slice_11097 : bool} =
    eq_i64(i32_res_11023, 0i64)
  let {m_11098 : i64} =
    sub64(i32_res_11023, 1i64)
  let {zero_leq_i_p_m_t_s_11099 : bool} =
    sle64(0i64, m_11098)
  let {i_p_m_t_s_leq_w_11100 : bool} =
    slt64(m_11098, N_9435)
  let {i_lte_j_11101 : bool} =
    sle64(0i64, i32_res_11023)
  let {y_11102 : bool} =
    logand(zero_leq_i_p_m_t_s_11099, i_p_m_t_s_leq_w_11100)
  let {forwards_ok_11103 : bool} =
    logand(i_lte_j_11101, y_11102)
  let {ok_or_empty_11104 : bool} =
    logor(empty_slice_11097, forwards_ok_11103)
  let {index_ok_11105 : bool} =
    logand(ok_or_empty_11096, ok_or_empty_11104)
  let {index_certs_11106 : unit} =
    assert(index_ok_11105, {"Index [", 0i64 : i64, ":, :", i32_res_11023 : i64, "] out of bounds for array of shape [", i32_res_11019 : i64, "][", N_9435 : i64, "]."}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:145:15-22")
  let {ok_or_empty_11107 : bool} =
    logor(empty_slice_11097, y_11102)
  let {index_ok_11108 : bool} =
    logand(ok_or_empty_11096, ok_or_empty_11107)
  let {index_certs_11109 : unit} =
    assert(index_ok_11108, {"Index [:", i32_res_11023 : i64, ", ", 0i64 : i64, ":] out of bounds for array of shape [", N_9435 : i64, "][", i32_res_11019 : i64, "]."}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:146:15-23")
  let {m_11114 : i64} =
    mul64(2i64, i32_res_11019)
  let {d<{(*) n m}>_11115 : i64} =
    mul64(i32_res_11019, m_11114)
  let {one_intra_par_min_12081 : i64} =
    mul_nw64(i32_res_11019, i32_res_11019)
  let {one_intra_par_min_12082 : i64} =
    mul_nw64(i32_res_11019, i32_res_11023)
  let {y_12086 : i64} =
    smin64(d<{(*) n m}>_11115, nest_size_11969)
  let {y_12087 : i64} =
    smin64(one_intra_par_min_12082, y_12086)
  let {intra_avail_par_12088 : i64} =
    smin64(one_intra_par_min_12081, y_12087)
  let {y_12089 : i64} =
    smax64(d<{(*) n m}>_11115, nest_size_11969)
  let {y_12090 : i64} =
    smax64(one_intra_par_min_12082, y_12089)
  let {computed_group_size_11981 : i64} =
    smax64(one_intra_par_min_12081, y_12090)
  let {max_group_size_12095 : i64} =
    get_size_max(group_size)
  let {fits_12096 : bool} =
    sle64(computed_group_size_11981, max_group_size_12095)
  let {suff_intra_par_12094 : bool} =
    cmp_size(suff_intra_par_0, threshold(32, )) <= intra_avail_par_12088
  let {intra_suff_and_fits_12097 : bool} =
    logand(suff_intra_par_12094, fits_12096)
  let {segmap_group_size_12532 : i64} =
    get_size(segmap_group_size_12324, group_size)
  let {defunc_0_map_res_11673 : [m_9436]i32,
       defunc_0_map_res_11674 : [m_9436]f32} =
    if <equiv> intra_suff_and_fits_12097
    then {
      let {defunc_0_map_res_12098 : [m_9436]i32,
           defunc_0_map_res_12099 : [m_9436]f32} =
        segmap(group; ; groups=m_9436; groupsize=computed_group_size_11981)
        (gtid_12100 < m_9436) (~phys_group_id_12101) : {i32, f32} {
          let {cond_12105 : bool} =
            slt64(50000000i64, gtid_12100)
          let {lifted_lambda_res_12106 : i32,
               lifted_lambda_res_12107 : f32} =
            if cond_12105
            then {-1i32, 0.0f32} else {
              let {defunc_0_map_res_12109 : [i32_res_11019][i32_res_11019]f32} =
                segmap(thread; ; )
                (gtid_12110 < i32_res_11019, gtid_12111 < i32_res_11019) (~phys_tid_12112) : {f32} {
                  let {dotprod_filt_res_12115 : f32} =
                    loop {s_12117 : f32} = {0.0f32}
                    for i_12116:i64 < i32_res_11023 do {
                      let {*_lhs_12118 : f32} =
                        #{index_certs_11106}
                        opaque_res_11070[gtid_12110, i_12116]
                      let {*_rhs_12119 : f32} =
                        #{index_certs_11109}
                        opaque_res_11090[i_12116, gtid_12111]
                      let {*_lhs_12120 : f32} =
                        fmul32(*_lhs_12118, *_rhs_12119)
                      let {isnan_arg0_12121 : f32} =
                        images_9444[gtid_12100, i_12116]
                      let {isnan_res_12122 : bool} =
                        apply isnan32(isnan_arg0_12121)
                        : {bool}
                      let {*_rhs_12123 : f32} =
                        if isnan_res_12122
                        then {0.0f32} else {1.0f32}
                        : {f32}
                      let {+_rhs_12124 : f32} =
                        fmul32(*_lhs_12120, *_rhs_12123)
                      let {loopres_12125 : f32} =
                        fadd32(s_12117, +_rhs_12124)
                      in {loopres_12125}
                    }
                  return {returns dotprod_filt_res_12115}
                }
              let {defunc_0_map_res_12126 : [i32_res_11019]f32} =
                segred(thread; ; )
                (gtid_12127 < i32_res_11019, gtid_12128 < i32_res_11023) (~phys_tid_12129)
                ({0.0f32},
                ,
                commutative \ {eta_p_12130 : f32,
                               eta_p_12131 : f32}
                  : {f32} ->
                  let {+_res_12132 : f32} =
                    fadd32(eta_p_12130, eta_p_12131)
                  in {+_res_12132})
                : {f32} {
                  let {eta_p_12135 : f32} =
                    images_9444[gtid_12100, gtid_12128]
                  let {isnan_res_12136 : bool} =
                    apply isnan32(eta_p_12135)
                    : {bool}
                  let {lifted_lambda_res_12137 : f32} =
                    if isnan_res_12136
                    then {0.0f32} else {
                      let {eta_p_12134 : f32} =
                        #{index_certs_11106}
                        opaque_res_11070[gtid_12127, gtid_12128]
                      let {lifted_lambda_res_f_res_12138 : f32} =
                        fmul32(eta_p_12134, eta_p_12135)
                      in {lifted_lambda_res_f_res_12138}
                    }
                    : {f32}
                  return {returns lifted_lambda_res_12137}
                }
              let {bounds_invalid_upwards_12139 : bool} =
                slt64(d<{(*) n m}>_11115, 0i64)
              let {valid_12140 : bool} =
                not bounds_invalid_upwards_12139
              let {range_valid_c_12141 : unit} =
                assert(valid_12140, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", d<{(*) n m}>_11115 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
              let {zero_12143 : bool} =
                eq_i64(m_11114, 0i64)
              let {nonzero_12144 : bool} =
                not zero_12143
              let {nonzero_cert_12145 : unit} =
                assert(nonzero_12144, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:84:45-48")
              let {defunc_0_map_res_12146 : [d<{(*) n m}>_11115]f32} =
                segmap(thread; ; )
                (gtid_12147 < d<{(*) n m}>_11115) (~phys_tid_12148) : {f32} {
                  let {tmp_12150 : i64} =
                    #{range_valid_c_12141, nonzero_cert_12145}
                    sdiv64(gtid_12147, m_11114)
                  let {tmp_12151 : i64} =
                    #{range_valid_c_12141, nonzero_cert_12145}
                    smod64(gtid_12147, m_11114)
                  let {cond_12152 : bool} =
                    slt64(tmp_12151, i32_res_11019)
                  let {lifted_lambda_res_12153 : f32} =
                    if cond_12152
                    then {
                      let {lifted_lambda_res_t_res_12154 : f32} =
                        defunc_0_map_res_12109[tmp_12150, tmp_12151]
                      in {lifted_lambda_res_t_res_12154}
                    } else {
                      let {==_rhs_12155 : i64} =
                        add64(i32_res_11019, tmp_12150)
                      let {cond_12156 : bool} =
                        eq_i64(tmp_12151, ==_rhs_12155)
                      let {lifted_lambda_res_f_res_12157 : f32} =
                        if cond_12156
                        then {1.0f32} else {0.0f32}
                        : {f32}
                      in {lifted_lambda_res_f_res_12157}
                    }
                    : {f32}
                  return {returns lifted_lambda_res_12153}
                }
              let {loop_nonempty_12158 : bool} =
                slt64(0i64, i32_res_11019)
              let {loop_not_taken_12159 : bool} =
                not loop_nonempty_12158
              let {protect_assert_disj_12160 : bool} =
                logor(nonzero_12144, loop_not_taken_12159)
              let {nonzero_cert_12161 : unit} =
                assert(protect_assert_disj_12160, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:72:47-50")
              let {<_rhs_12162 : i64} =
                sub64(i32_res_11019, 1i64)
              let {gauss_jordan_res_12163 : [d<{(*) n m}>_11115]f32} =
                loop {A_12165 : *[d<{(*) n m}>_11115]f32} = {defunc_0_map_res_12146}
                for i_12164:i64 < i32_res_11019 do {
                  let {y_12166 : bool} =
                    slt64(i_12164, d<{(*) n m}>_11115)
                  let {index_certs_12167 : unit} =
                    assert(y_12166, {"Index [", i_12164 : i64, "] out of bounds for array of shape [", d<{(*) n m}>_11115 : i64, "]."}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:71:16-20")
                  let {v1_12168 : f32} =
                    #{index_certs_12167}
                    A_12165[i_12164]
                  let {cond_12169 : bool} =
                    eq_f32(v1_12168, 0.0f32)
                  let {defunc_0_map_res_12170 : [d<{(*) n m}>_11115]f32} =
                    segmap(thread; ; )
                    (gtid_12171 < d<{(*) n m}>_11115) (~phys_tid_12172) : {f32} {
                      let {tmp_12174 : i64} =
                        #{range_valid_c_12141, nonzero_cert_12161}
                        sdiv64(gtid_12171, m_11114)
                      let {tmp_12175 : i64} =
                        #{range_valid_c_12141, nonzero_cert_12161}
                        smod64(gtid_12171, m_11114)
                      let {lifted_lambda_res_12176 : f32} =
                        if cond_12169
                        then {
                          let {+_lhs_12177 : i64} =
                            mul64(m_11114, tmp_12174)
                          let {tmp_12178 : i64} =
                            add64(tmp_12175, +_lhs_12177)
                          let {lifted_lambda_res_t_res_12179 : f32} =
                            A_12165[tmp_12178]
                          in {lifted_lambda_res_t_res_12179}
                        } else {
                          let {/_lhs_12180 : f32} =
                            A_12165[tmp_12175]
                          let {x_12181 : f32} =
                            fdiv32(/_lhs_12180, v1_12168)
                          let {cond_12182 : bool} =
                            slt64(tmp_12174, <_rhs_12162)
                          let {lifted_lambda_res_f_res_12183 : f32} =
                            if cond_12182
                            then {
                              let {*_lhs_12184 : i64} =
                                add64(1i64, tmp_12174)
                              let {+_lhs_12185 : i64} =
                                mul64(m_11114, *_lhs_12184)
                              let {-_lhs_12186 : i64} =
                                add64(tmp_12175, +_lhs_12185)
                              let {-_lhs_12187 : f32} =
                                A_12165[-_lhs_12186]
                              let {*_lhs_12188 : i64} =
                                add64(i_12164, +_lhs_12185)
                              let {*_lhs_12189 : f32} =
                                A_12165[*_lhs_12188]
                              let {-_rhs_12190 : f32} =
                                fmul32(x_12181, *_lhs_12189)
                              let {lifted_lambda_res_f_res_t_res_12191 : f32} =
                                fsub32(-_lhs_12187, -_rhs_12190)
                              in {lifted_lambda_res_f_res_t_res_12191}
                            } else {x_12181}
                            : {f32}
                          in {lifted_lambda_res_f_res_12183}
                        }
                        : {f32}
                      return {returns lifted_lambda_res_12176}
                    }
                  let {scatter_res_12192 : [d<{(*) n m}>_11115]f32} =
                    segmap(thread; ; )
                    (write_i_12193 < d<{(*) n m}>_11115) (~phys_tid_12194) : {f32} {
                      let {write_value_12196 : f32} =
                        #{range_valid_c_12141}
                        defunc_0_map_res_12170[write_i_12193]
                      return {A_12165 : [d<{(*) n m}>_11115]
                              with ([write_i_12193] = write_value_12196)}
                    }
                  in {scatter_res_12192}
                }
              let {defunc_0_map_res_12199 : [i32_res_11019]f32} =
                segred(thread; ; )
                (gtid_12200 < i32_res_11019, gtid_12201 < i32_res_11019) (~phys_tid_12202)
                ({0.0f32},
                ,
                commutative \ {eta_p_12203 : f32,
                               eta_p_12204 : f32}
                  : {f32} ->
                  let {defunc_0_op_res_12205 : f32} =
                    fadd32(eta_p_12203, eta_p_12204)
                  in {defunc_0_op_res_12205})
                : {f32} {
                  let {eta_p_12207 : f32} =
                    defunc_0_map_res_12126[gtid_12201]
                  let {slice_12742 : i64} =
                    add_nw64(i32_res_11019, gtid_12201)
                  let {binop_x_12757 : i64} =
                    mul_nw64(m_11114, gtid_12200)
                  let {new_index_12758 : i64} =
                    add_nw64(slice_12742, binop_x_12757)
                  let {eta_p_12208 : f32} =
                    gauss_jordan_res_12163[new_index_12758]
                  let {defunc_0_f_res_12209 : f32} =
                    fmul32(eta_p_12207, eta_p_12208)
                  return {returns defunc_0_f_res_12209}
                }
              let {defunc_0_map_res_12210 : [N_9435]f32} =
                segred(thread; ; )
                (gtid_12211 < N_9435, gtid_12212 < i32_res_11019) (~phys_tid_12213)
                ({0.0f32},
                ,
                commutative \ {eta_p_12214 : f32,
                               eta_p_12215 : f32}
                  : {f32} ->
                  let {defunc_0_op_res_12216 : f32} =
                    fadd32(eta_p_12214, eta_p_12215)
                  in {defunc_0_op_res_12216})
                : {f32} {
                  let {eta_p_12218 : f32} =
                    defunc_0_map_res_12199[gtid_12212]
                  let {eta_p_12219 : f32} =
                    opaque_res_11090[gtid_12211, gtid_12212]
                  let {defunc_0_f_res_12220 : f32} =
                    fmul32(eta_p_12218, eta_p_12219)
                  return {returns defunc_0_f_res_12220}
                }
              let {defunc_0_map_res_12221 : [N_9435]f32} =
                replicate([N_9435], f32.nan)
              let {defunc_0_map_res_12222 : [N_9435]i32} =
                replicate([N_9435], 0i32)
              let {lifted_lambda_res_f_res_12223 : i32,
                   lifted_lambda_res_f_res_12224 : i32,
                   lifted_lambda_res_f_res_12225 : f32,
                   lifted_lambda_res_f_res_12226 : [N_9435]f32,
                   lifted_lambda_res_f_res_12227 : [N_9435]i32} =
                loop {count_12229 : i32,
                      n'_12230 : i32,
                      sigma0_12231 : f32,
                      yerr_12232 : *[N_9435]f32,
                      keys_12233 : *[N_9435]i32} = {0i32, 0i32, 0.0f32, defunc_0_map_res_12221, defunc_0_map_res_12222}
                for i_12228:i64 < N_9435 do {
                  let {yi_12234 : f32} =
                    images_9444[gtid_12100, i_12228]
                  let {isnan_res_12235 : bool} =
                    apply isnan32(yi_12234)
                    : {bool}
                  let {loopres_12236 : i32,
                       loopres_12237 : i32,
                       loopres_12238 : f32,
                       loopres_12239 : [N_9435]f32,
                       loopres_12240 : [N_9435]i32} =
                    if isnan_res_12235
                    then {count_12229, n'_12230, sigma0_12231, yerr_12232, keys_12233} else {
                      let {-_rhs_12241 : f32} =
                        defunc_0_map_res_12210[i_12228]
                      let {ye_12242 : f32} =
                        fsub32(yi_12234, -_rhs_12241)
                      let {count_12243 : i64} =
                        sext i32 count_12229 to i64
                      let {yerr_12244 : [N_9435]f32} =
                        yerr_12232 with [count_12243] = ye_12242
                      let {i64_res_12245 : i32} =
                        sext i64 i_12228 to i32
                      let {keys_12246 : [N_9435]i32} =
                        keys_12233 with [count_12243] = i64_res_12245
                      let {cond_12247 : bool} =
                        slt64(i_12228, i32_res_11023)
                      let {loopres_f_res_12248 : i32,
                           loopres_f_res_12249 : f32} =
                        if cond_12247
                        then {
                          let {tmp_12250 : i32} =
                            add32(1i32, n'_12230)
                          let {+_rhs_12251 : f32} =
                            fmul32(ye_12242, ye_12242)
                          let {tmp_12252 : f32} =
                            fadd32(sigma0_12231, +_rhs_12251)
                          in {tmp_12250, tmp_12252}
                        } else {n'_12230, sigma0_12231}
                        : {i32,
                           f32}
                      let {tmp_12253 : i32} =
                        add32(1i32, count_12229)
                      in {tmp_12253, loopres_f_res_12248, loopres_f_res_12249, yerr_12244, keys_12246}
                    }
                    : {i32,
                       i32,
                       f32,
                       [N_9435]f32,
                       [N_9435]i32}
                  in {loopres_12236, loopres_12237, loopres_12238, loopres_12239, loopres_12240}
                }
              let {r32_arg0_12254 : i32} =
                sub32(lifted_lambda_res_f_res_12224, k2p2_11015)
              let {i32_res_12255 : f32} =
                sitofp i32 r32_arg0_12254 to f32
              let {sqrt_arg0_12256 : f32} =
                fdiv32(lifted_lambda_res_f_res_12225, i32_res_12255)
              let {sqrt_res_12257 : f32} =
                apply sqrt32(sqrt_arg0_12256)
                : {f32}
              let {i32_res_12258 : f32} =
                sitofp i32 lifted_lambda_res_f_res_12224 to f32
              let {t32_arg0_12259 : f32} =
                fmul32(hfrac_9441, i32_res_12258)
              let {f32_res_12260 : i32} =
                fptosi f32 t32_arg0_12259 to i32
              let {MO_fst_12261 : f32} =
                loop {acc_12263 : f32} = {0.0f32}
                for i_12262:i32 < f32_res_12260 do {
                  let {-_lhs_12264 : i32} =
                    add32(lifted_lambda_res_f_res_12224, i_12262)
                  let {+_lhs_12265 : i32} =
                    sub32(-_lhs_12264, f32_res_12260)
                  let {+_rhs_12266 : i32} =
                    add32(1i32, +_lhs_12265)
                  let {+_rhs_12267 : i64} =
                    sext i32 +_rhs_12266 to i64
                  let {+_rhs_12268 : f32} =
                    lifted_lambda_res_f_res_12226[+_rhs_12267]
                  let {loopres_12269 : f32} =
                    fadd32(acc_12263, +_rhs_12268)
                  in {loopres_12269}
                }
              let {upper_bound_12270 : i32} =
                sub32(lifted_lambda_res_f_res_12223, lifted_lambda_res_f_res_12224)
              let {sqrt_res_12271 : f32} =
                apply sqrt32(i32_res_12258)
                : {f32}
              let {/_rhs_12272 : f32} =
                fmul32(sqrt_res_12257, sqrt_res_12271)
              let {lifted_lambda_res_f_res_12273 : i32,
                   lifted_lambda_res_f_res_12274 : f32,
                   lifted_lambda_res_f_res_12275 : f32} =
                loop {fst_break_12277 : i32,
                      mean_12278 : f32,
                      mo_12279 : f32} = {-1i32, 0.0f32, 0.0f32}
                for i_12276:i32 < upper_bound_12270 do {
                  let {cond_12280 : bool} =
                    eq_i32(i_12276, 0i32)
                  let {elm_12281 : f32} =
                    if cond_12280
                    then {MO_fst_12261} else {
                      let {+_lhs_12282 : i32} =
                        sub32(lifted_lambda_res_f_res_12224, f32_res_12260)
                      let {+_lhs_12283 : i32} =
                        add32(i_12276, +_lhs_12282)
                      let {+_lhs_12284 : i64} =
                        sext i32 +_lhs_12283 to i64
                      let {+_lhs_12285 : f32} =
                        lifted_lambda_res_f_res_12226[+_lhs_12284]
                      let {+_rhs_12286 : i32} =
                        add32(lifted_lambda_res_f_res_12224, i_12276)
                      let {+_rhs_12287 : i64} =
                        sext i32 +_rhs_12286 to i64
                      let {+_rhs_12288 : f32} =
                        lifted_lambda_res_f_res_12226[+_rhs_12287]
                      let {arg_12289 : f32} =
                        fsub32(0.0f32, +_lhs_12285)
                      let {elm_f_res_12290 : f32} =
                        fadd32(+_rhs_12288, arg_12289)
                      in {elm_f_res_12290}
                    }
                    : {f32}
                  let {mo_12291 : f32} =
                    fadd32(mo_12279, elm_12281)
                  let {mo'_12292 : f32} =
                    fdiv32(mo_12291, /_rhs_12272)
                  let {cond_12293 : bool} =
                    eq_i32(fst_break_12277, -1i32)
                  let {isnan_res_12294 : bool} =
                    apply isnan32(mo'_12292)
                    : {bool}
                  let {cond_t_res_12295 : bool} =
                    not isnan_res_12294
                  let {x_12296 : bool} =
                    logand(cond_12293, cond_t_res_12295)
                  let {abs_res_12297 : f32} =
                    fabs32 mo'_12292
                  let {cond_t_res_12298 : bool} =
                    lt32(1.0001f32, abs_res_12297)
                  let {x_12299 : bool} =
                    logand(x_12296, cond_t_res_12298)
                  let {fst_break_12300 : i32} =
                    if x_12299
                    then {i_12276} else {fst_break_12277}
                    : {i32}
                  let {tmp_12301 : f32} =
                    fadd32(mean_12278, mo'_12292)
                  in {fst_break_12300, tmp_12301, mo_12291}
                }
              let {cond_12302 : bool} =
                eq_i32(lifted_lambda_res_f_res_12273, -1i32)
              let {fst_break'_12303 : i32} =
                if cond_12302
                then {-1i32} else {
                  let {cond_12304 : bool} =
                    slt32(lifted_lambda_res_f_res_12273, upper_bound_12270)
                  let {adjustValInds_res_12305 : i32} =
                    if cond_12304
                    then {
                      let {-_lhs_12306 : i32} =
                        add32(lifted_lambda_res_f_res_12224, lifted_lambda_res_f_res_12273)
                      let {-_lhs_12307 : i64} =
                        sext i32 -_lhs_12306 to i64
                      let {-_lhs_12308 : i32} =
                        lifted_lambda_res_f_res_12227[-_lhs_12307]
                      let {adjustValInds_res_t_res_12309 : i32} =
                        sub32(-_lhs_12308, n_9439)
                      in {adjustValInds_res_t_res_12309}
                    } else {-1i32}
                    : {i32}
                  let {/_lhs_12310 : i32} =
                    sub32(adjustValInds_res_12305, 1i32)
                  let {*_lhs_12311 : i32} =
                    sdiv32(/_lhs_12310, 2i32)
                  let {+_lhs_12312 : i32} =
                    mul32(2i32, *_lhs_12311)
                  let {fst_break'_f_res_12313 : i32} =
                    add32(1i32, +_lhs_12312)
                  in {fst_break'_f_res_12313}
                }
                : {i32}
              let {cond_12314 : bool} =
                sle32(lifted_lambda_res_f_res_12224, 5i32)
              let {cond_f_res_12315 : bool} =
                sle32(upper_bound_12270, 5i32)
              let {x_12316 : bool} =
                not cond_12314
              let {y_12317 : bool} =
                logand(cond_f_res_12315, x_12316)
              let {cond_12318 : bool} =
                logor(cond_12314, y_12317)
              let {fst_break'_12319 : i32} =
                if cond_12318
                then {-2i32} else {fst_break'_12303}
                : {i32}
              in {fst_break'_12319, lifted_lambda_res_f_res_12274}
            }
            : {i32,
               f32}
          return {returns lifted_lambda_res_12106,
                  returns lifted_lambda_res_12107}
        }
      in {defunc_0_map_res_12098, defunc_0_map_res_12099}
    } else {
      let {segmap_usable_groups_12533 : i64} =
        sdiv_up64(m_9436, segmap_group_size_12532)
      let {defunc_0_map_res_12534 : [m_9436]i32,
           defunc_0_map_res_12535 : [m_9436]f32} =
        segmap(thread; ; groups=segmap_usable_groups_12533; groupsize=segmap_group_size_12532)
        (gtid_12536 < m_9436) (~phys_tid_12537) : {i32, f32} {
          let {cond_12540 : bool} =
            slt64(50000000i64, gtid_12536)
          let {lifted_lambda_res_12541 : i32,
               lifted_lambda_res_12542 : f32} =
            if cond_12540
            then {-1i32, 0.0f32} else {
              let {result_12790 : [i32_res_11019]f32} =
                scratch(f32, i32_res_11019)
              let {result_12791 : [i32_res_11019][i32_res_11019]f32} =
                scratch(f32, i32_res_11019, i32_res_11019)
              let {defunc_0_map_res_12544 : [i32_res_11019]f32,
                   defunc_0_map_res_12545 : [i32_res_11019][i32_res_11019]f32} =
                loop {mapout_12792 : *[i32_res_11019]f32,
                      mapout_12793 : *[i32_res_11019][i32_res_11019]f32} = {result_12790, result_12791}
                for i_12794:i64 < i32_res_11019 do {
                  let {result_12797 : [i32_res_11019]f32} =
                    scratch(f32, i32_res_11019)
                  let {modified_source_12839 : [i32_res_11019][i32_res_11019]f32} =
                    mapout_12793 with [i_12794, 0i64 :+ i32_res_11019 * 1i64] = result_12797
                  let {lw_dest_12796 : [i32_res_11019][i32_res_11019]f32} =
                    loop {lowered_array_12838 : *[i32_res_11019][i32_res_11019]f32} = {modified_source_12839}
                    for i_12799:i64 < i32_res_11019 do {
                      let {dotprod_filt_res_12549 : f32} =
                        loop {s_12551 : f32} = {0.0f32}
                        for i_12550:i64 < i32_res_11023 do {
                          let {*_lhs_12552 : f32} =
                            #{index_certs_11106}
                            opaque_res_11070[i_12794, i_12550]
                          let {*_rhs_12553 : f32} =
                            #{index_certs_11109}
                            opaque_res_11090[i_12550, i_12799]
                          let {*_lhs_12554 : f32} =
                            fmul32(*_lhs_12552, *_rhs_12553)
                          let {isnan_arg0_12555 : f32} =
                            images_9444[gtid_12536, i_12550]
                          let {isnan_res_12556 : bool} =
                            apply isnan32(isnan_arg0_12555)
                            : {bool}
                          let {*_rhs_12557 : f32} =
                            if isnan_res_12556
                            then {0.0f32} else {1.0f32}
                            : {f32}
                          let {+_rhs_12558 : f32} =
                            fmul32(*_lhs_12554, *_rhs_12557)
                          let {loopres_12559 : f32} =
                            fadd32(s_12551, +_rhs_12558)
                          in {loopres_12559}
                        }
                      let {mapout_row_12841 : [i32_res_11019]f32} =
                        lowered_array_12838[i_12794, 0i64 :+ i32_res_11019 * 1i64]
                      let {mapout_row_copy_12842 : [i32_res_11019]f32} =
                        copy(mapout_row_12841)
                      let {lw_dest_12800 : [i32_res_11019]f32} =
                        mapout_row_copy_12842 with [i_12799] = dotprod_filt_res_12549
                      let {lowered_array_updated_12843 : [i32_res_11019][i32_res_11019]f32} =
                        lowered_array_12838 with [i_12794, 0i64 :+ i32_res_11019 * 1i64] = lw_dest_12800
                      in {lowered_array_updated_12843}
                    }
                  let {defunc_0_map_res_precopy_12840 : [i32_res_11019]f32} =
                    lw_dest_12796[i_12794, 0i64 :+ i32_res_11019 * 1i64]
                  let {defunc_0_map_res_12547 : [i32_res_11019]f32} =
                    copy(defunc_0_map_res_precopy_12840)
                  let {defunc_res_12560 : f32} =
                    loop {redout_12801 : f32} = {0.0f32}
                    for i_12802:i64 < i32_res_11023 do {
                      let {eta_p_12565 : f32} =
                        images_9444[gtid_12536, i_12802]
                      let {isnan_res_12566 : bool} =
                        apply isnan32(eta_p_12565)
                        : {bool}
                      let {lifted_lambda_res_12567 : f32} =
                        if isnan_res_12566
                        then {0.0f32} else {
                          let {eta_p_12564 : f32} =
                            #{index_certs_11106}
                            opaque_res_11070[i_12794, i_12802]
                          let {lifted_lambda_res_f_res_12568 : f32} =
                            fmul32(eta_p_12564, eta_p_12565)
                          in {lifted_lambda_res_f_res_12568}
                        }
                        : {f32}
                      let {+_res_12563 : f32} =
                        fadd32(lifted_lambda_res_12567, redout_12801)
                      in {+_res_12563}
                    }
                  let {lw_dest_12795 : [i32_res_11019]f32} =
                    mapout_12792 with [i_12794] = defunc_res_12560
                  in {lw_dest_12795, lw_dest_12796}
                }
              let {bounds_invalid_upwards_12569 : bool} =
                slt64(d<{(*) n m}>_11115, 0i64)
              let {valid_12570 : bool} =
                not bounds_invalid_upwards_12569
              let {range_valid_c_12571 : unit} =
                assert(valid_12570, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", d<{(*) n m}>_11115 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
              let {zero_12573 : bool} =
                eq_i64(m_11114, 0i64)
              let {nonzero_12574 : bool} =
                not zero_12573
              let {nonzero_cert_12575 : unit} =
                assert(nonzero_12574, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:84:45-48")
              let {result_12803 : [d<{(*) n m}>_11115]f32} =
                scratch(f32, d<{(*) n m}>_11115)
              let {defunc_0_map_res_12576 : [d<{(*) n m}>_11115]f32} =
                loop {mapout_12804 : *[d<{(*) n m}>_11115]f32} = {result_12803}
                for i_12805:i64 < d<{(*) n m}>_11115 do {
                  let {tmp_12578 : i64} =
                    #{range_valid_c_12571, nonzero_cert_12575}
                    sdiv64(i_12805, m_11114)
                  let {tmp_12579 : i64} =
                    #{range_valid_c_12571, nonzero_cert_12575}
                    smod64(i_12805, m_11114)
                  let {cond_12580 : bool} =
                    slt64(tmp_12579, i32_res_11019)
                  let {lifted_lambda_res_12581 : f32} =
                    if cond_12580
                    then {
                      let {lifted_lambda_res_t_res_12582 : f32} =
                        defunc_0_map_res_12545[tmp_12578, tmp_12579]
                      in {lifted_lambda_res_t_res_12582}
                    } else {
                      let {==_rhs_12583 : i64} =
                        add64(i32_res_11019, tmp_12578)
                      let {cond_12584 : bool} =
                        eq_i64(tmp_12579, ==_rhs_12583)
                      let {lifted_lambda_res_f_res_12585 : f32} =
                        if cond_12584
                        then {1.0f32} else {0.0f32}
                        : {f32}
                      in {lifted_lambda_res_f_res_12585}
                    }
                    : {f32}
                  let {lw_dest_12806 : [d<{(*) n m}>_11115]f32} =
                    mapout_12804 with [i_12805] = lifted_lambda_res_12581
                  in {lw_dest_12806}
                }
              let {loop_nonempty_12586 : bool} =
                slt64(0i64, i32_res_11019)
              let {loop_not_taken_12587 : bool} =
                not loop_nonempty_12586
              let {protect_assert_disj_12588 : bool} =
                logor(nonzero_12574, loop_not_taken_12587)
              let {nonzero_cert_12589 : unit} =
                assert(protect_assert_disj_12588, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:72:47-50")
              let {<_rhs_12590 : i64} =
                sub64(i32_res_11019, 1i64)
              let {gauss_jordan_res_12591 : [d<{(*) n m}>_11115]f32} =
                loop {A_12593 : *[d<{(*) n m}>_11115]f32} = {defunc_0_map_res_12576}
                for i_12592:i64 < i32_res_11019 do {
                  let {y_12594 : bool} =
                    slt64(i_12592, d<{(*) n m}>_11115)
                  let {index_certs_12595 : unit} =
                    assert(y_12594, {"Index [", i_12592 : i64, "] out of bounds for array of shape [", d<{(*) n m}>_11115 : i64, "]."}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/bfast-All-EfSeq.fut:71:16-20")
                  let {v1_12596 : f32} =
                    #{index_certs_12595}
                    A_12593[i_12592]
                  let {cond_12597 : bool} =
                    eq_f32(v1_12596, 0.0f32)
                  let {result_12807 : [d<{(*) n m}>_11115]f32} =
                    scratch(f32, d<{(*) n m}>_11115)
                  let {defunc_0_map_res_12598 : [d<{(*) n m}>_11115]f32} =
                    loop {mapout_12808 : *[d<{(*) n m}>_11115]f32} = {result_12807}
                    for i_12809:i64 < d<{(*) n m}>_11115 do {
                      let {tmp_12600 : i64} =
                        #{range_valid_c_12571, nonzero_cert_12589}
                        sdiv64(i_12809, m_11114)
                      let {tmp_12601 : i64} =
                        #{range_valid_c_12571, nonzero_cert_12589}
                        smod64(i_12809, m_11114)
                      let {lifted_lambda_res_12602 : f32} =
                        if cond_12597
                        then {
                          let {+_lhs_12603 : i64} =
                            mul64(m_11114, tmp_12600)
                          let {tmp_12604 : i64} =
                            add64(tmp_12601, +_lhs_12603)
                          let {lifted_lambda_res_t_res_12605 : f32} =
                            A_12593[tmp_12604]
                          in {lifted_lambda_res_t_res_12605}
                        } else {
                          let {/_lhs_12606 : f32} =
                            A_12593[tmp_12601]
                          let {x_12607 : f32} =
                            fdiv32(/_lhs_12606, v1_12596)
                          let {cond_12608 : bool} =
                            slt64(tmp_12600, <_rhs_12590)
                          let {lifted_lambda_res_f_res_12609 : f32} =
                            if cond_12608
                            then {
                              let {*_lhs_12610 : i64} =
                                add64(1i64, tmp_12600)
                              let {+_lhs_12611 : i64} =
                                mul64(m_11114, *_lhs_12610)
                              let {-_lhs_12612 : i64} =
                                add64(tmp_12601, +_lhs_12611)
                              let {-_lhs_12613 : f32} =
                                A_12593[-_lhs_12612]
                              let {*_lhs_12614 : i64} =
                                add64(i_12592, +_lhs_12611)
                              let {*_lhs_12615 : f32} =
                                A_12593[*_lhs_12614]
                              let {-_rhs_12616 : f32} =
                                fmul32(x_12607, *_lhs_12615)
                              let {lifted_lambda_res_f_res_t_res_12617 : f32} =
                                fsub32(-_lhs_12613, -_rhs_12616)
                              in {lifted_lambda_res_f_res_t_res_12617}
                            } else {x_12607}
                            : {f32}
                          in {lifted_lambda_res_f_res_12609}
                        }
                        : {f32}
                      let {lw_dest_12810 : [d<{(*) n m}>_11115]f32} =
                        mapout_12808 with [i_12809] = lifted_lambda_res_12602
                      in {lw_dest_12810}
                    }
                  let {scatter_res_12618 : [d<{(*) n m}>_11115]f32} =
                    loop {write_out_12812 : *[d<{(*) n m}>_11115]f32} = {A_12593}
                    for write_iter_12811:i64 < d<{(*) n m}>_11115 do {
                      let {write_iv_slice_12829 : [1i64]f32} =
                        defunc_0_map_res_12598[write_iter_12811 :+ 1i64 * 1i64]
                      let {write_out_12815 : [d<{(*) n m}>_11115]f32} =
                        #{range_valid_c_12571}
                        write_out_12812 with? [write_iter_12811 :+ 1i64 * 1i64] = write_iv_slice_12829
                      in {write_out_12815}
                    }
                  in {scatter_res_12618}
                }
              let {result_12816 : [i32_res_11019]f32} =
                scratch(f32, i32_res_11019)
              let {defunc_0_map_res_12623 : [i32_res_11019]f32} =
                loop {mapout_12817 : *[i32_res_11019]f32} = {result_12816}
                for i_12818:i64 < i32_res_11019 do {
                  let {binop_x_12836 : i64} =
                    mul_nw64(m_11114, i_12818)
                  let {defunc_0_f_res_12625 : f32} =
                    loop {redout_12820 : f32} = {0.0f32}
                    for i_12821:i64 < i32_res_11019 do {
                      let {eta_p_12629 : f32} =
                        defunc_0_map_res_12544[i_12821]
                      let {slice_12828 : i64} =
                        add_nw64(i32_res_11019, i_12821)
                      let {new_index_12837 : i64} =
                        add_nw64(slice_12828, binop_x_12836)
                      let {eta_p_12630 : f32} =
                        gauss_jordan_res_12591[new_index_12837]
                      let {defunc_0_f_res_12631 : f32} =
                        fmul32(eta_p_12629, eta_p_12630)
                      let {defunc_0_op_res_12628 : f32} =
                        fadd32(defunc_0_f_res_12631, redout_12820)
                      in {defunc_0_op_res_12628}
                    }
                  let {lw_dest_12819 : [i32_res_11019]f32} =
                    mapout_12817 with [i_12818] = defunc_0_f_res_12625
                  in {lw_dest_12819}
                }
              let {result_12822 : [N_9435]f32} =
                scratch(f32, N_9435)
              let {defunc_0_map_res_12632 : [N_9435]f32} =
                loop {mapout_12823 : *[N_9435]f32} = {result_12822}
                for i_12824:i64 < N_9435 do {
                  let {defunc_0_f_res_12634 : f32} =
                    loop {redout_12826 : f32} = {0.0f32}
                    for i_12827:i64 < i32_res_11019 do {
                      let {eta_p_12638 : f32} =
                        defunc_0_map_res_12623[i_12827]
                      let {eta_p_12639 : f32} =
                        opaque_res_11090[i_12824, i_12827]
                      let {defunc_0_f_res_12640 : f32} =
                        fmul32(eta_p_12638, eta_p_12639)
                      let {defunc_0_op_res_12637 : f32} =
                        fadd32(defunc_0_f_res_12640, redout_12826)
                      in {defunc_0_op_res_12637}
                    }
                  let {lw_dest_12825 : [N_9435]f32} =
                    mapout_12823 with [i_12824] = defunc_0_f_res_12634
                  in {lw_dest_12825}
                }
              let {defunc_0_map_res_12641 : [N_9435]f32} =
                replicate([N_9435], f32.nan)
              let {defunc_0_map_res_12642 : [N_9435]i32} =
                replicate([N_9435], 0i32)
              let {lifted_lambda_res_f_res_12643 : i32,
                   lifted_lambda_res_f_res_12644 : i32,
                   lifted_lambda_res_f_res_12645 : f32,
                   lifted_lambda_res_f_res_12646 : [N_9435]f32,
                   lifted_lambda_res_f_res_12647 : [N_9435]i32} =
                loop {count_12649 : i32,
                      n'_12650 : i32,
                      sigma0_12651 : f32,
                      yerr_12652 : *[N_9435]f32,
                      keys_12653 : *[N_9435]i32} = {0i32, 0i32, 0.0f32, defunc_0_map_res_12641, defunc_0_map_res_12642}
                for i_12648:i64 < N_9435 do {
                  let {yi_12654 : f32} =
                    images_9444[gtid_12536, i_12648]
                  let {isnan_res_12655 : bool} =
                    apply isnan32(yi_12654)
                    : {bool}
                  let {loopres_12656 : i32,
                       loopres_12657 : i32,
                       loopres_12658 : f32,
                       loopres_12659 : [N_9435]f32,
                       loopres_12660 : [N_9435]i32} =
                    if isnan_res_12655
                    then {count_12649, n'_12650, sigma0_12651, yerr_12652, keys_12653} else {
                      let {-_rhs_12661 : f32} =
                        defunc_0_map_res_12632[i_12648]
                      let {ye_12662 : f32} =
                        fsub32(yi_12654, -_rhs_12661)
                      let {count_12663 : i64} =
                        sext i32 count_12649 to i64
                      let {yerr_12664 : [N_9435]f32} =
                        yerr_12652 with [count_12663] = ye_12662
                      let {i64_res_12665 : i32} =
                        sext i64 i_12648 to i32
                      let {keys_12666 : [N_9435]i32} =
                        keys_12653 with [count_12663] = i64_res_12665
                      let {cond_12667 : bool} =
                        slt64(i_12648, i32_res_11023)
                      let {loopres_f_res_12668 : i32,
                           loopres_f_res_12669 : f32} =
                        if cond_12667
                        then {
                          let {tmp_12670 : i32} =
                            add32(1i32, n'_12650)
                          let {+_rhs_12671 : f32} =
                            fmul32(ye_12662, ye_12662)
                          let {tmp_12672 : f32} =
                            fadd32(sigma0_12651, +_rhs_12671)
                          in {tmp_12670, tmp_12672}
                        } else {n'_12650, sigma0_12651}
                        : {i32,
                           f32}
                      let {tmp_12673 : i32} =
                        add32(1i32, count_12649)
                      in {tmp_12673, loopres_f_res_12668, loopres_f_res_12669, yerr_12664, keys_12666}
                    }
                    : {i32,
                       i32,
                       f32,
                       [N_9435]f32,
                       [N_9435]i32}
                  in {loopres_12656, loopres_12657, loopres_12658, loopres_12659, loopres_12660}
                }
              let {r32_arg0_12674 : i32} =
                sub32(lifted_lambda_res_f_res_12644, k2p2_11015)
              let {i32_res_12675 : f32} =
                sitofp i32 r32_arg0_12674 to f32
              let {sqrt_arg0_12676 : f32} =
                fdiv32(lifted_lambda_res_f_res_12645, i32_res_12675)
              let {sqrt_res_12677 : f32} =
                apply sqrt32(sqrt_arg0_12676)
                : {f32}
              let {i32_res_12678 : f32} =
                sitofp i32 lifted_lambda_res_f_res_12644 to f32
              let {t32_arg0_12679 : f32} =
                fmul32(hfrac_9441, i32_res_12678)
              let {f32_res_12680 : i32} =
                fptosi f32 t32_arg0_12679 to i32
              let {MO_fst_12681 : f32} =
                loop {acc_12683 : f32} = {0.0f32}
                for i_12682:i32 < f32_res_12680 do {
                  let {-_lhs_12684 : i32} =
                    add32(lifted_lambda_res_f_res_12644, i_12682)
                  let {+_lhs_12685 : i32} =
                    sub32(-_lhs_12684, f32_res_12680)
                  let {+_rhs_12686 : i32} =
                    add32(1i32, +_lhs_12685)
                  let {+_rhs_12687 : i64} =
                    sext i32 +_rhs_12686 to i64
                  let {+_rhs_12688 : f32} =
                    lifted_lambda_res_f_res_12646[+_rhs_12687]
                  let {loopres_12689 : f32} =
                    fadd32(acc_12683, +_rhs_12688)
                  in {loopres_12689}
                }
              let {upper_bound_12690 : i32} =
                sub32(lifted_lambda_res_f_res_12643, lifted_lambda_res_f_res_12644)
              let {sqrt_res_12691 : f32} =
                apply sqrt32(i32_res_12678)
                : {f32}
              let {/_rhs_12692 : f32} =
                fmul32(sqrt_res_12677, sqrt_res_12691)
              let {lifted_lambda_res_f_res_12693 : i32,
                   lifted_lambda_res_f_res_12694 : f32,
                   lifted_lambda_res_f_res_12695 : f32} =
                loop {fst_break_12697 : i32,
                      mean_12698 : f32,
                      mo_12699 : f32} = {-1i32, 0.0f32, 0.0f32}
                for i_12696:i32 < upper_bound_12690 do {
                  let {cond_12700 : bool} =
                    eq_i32(i_12696, 0i32)
                  let {elm_12701 : f32} =
                    if cond_12700
                    then {MO_fst_12681} else {
                      let {+_lhs_12702 : i32} =
                        sub32(lifted_lambda_res_f_res_12644, f32_res_12680)
                      let {+_lhs_12703 : i32} =
                        add32(i_12696, +_lhs_12702)
                      let {+_lhs_12704 : i64} =
                        sext i32 +_lhs_12703 to i64
                      let {+_lhs_12705 : f32} =
                        lifted_lambda_res_f_res_12646[+_lhs_12704]
                      let {+_rhs_12706 : i32} =
                        add32(lifted_lambda_res_f_res_12644, i_12696)
                      let {+_rhs_12707 : i64} =
                        sext i32 +_rhs_12706 to i64
                      let {+_rhs_12708 : f32} =
                        lifted_lambda_res_f_res_12646[+_rhs_12707]
                      let {arg_12709 : f32} =
                        fsub32(0.0f32, +_lhs_12705)
                      let {elm_f_res_12710 : f32} =
                        fadd32(+_rhs_12708, arg_12709)
                      in {elm_f_res_12710}
                    }
                    : {f32}
                  let {mo_12711 : f32} =
                    fadd32(mo_12699, elm_12701)
                  let {mo'_12712 : f32} =
                    fdiv32(mo_12711, /_rhs_12692)
                  let {cond_12713 : bool} =
                    eq_i32(fst_break_12697, -1i32)
                  let {isnan_res_12714 : bool} =
                    apply isnan32(mo'_12712)
                    : {bool}
                  let {cond_t_res_12715 : bool} =
                    not isnan_res_12714
                  let {x_12716 : bool} =
                    logand(cond_12713, cond_t_res_12715)
                  let {abs_res_12717 : f32} =
                    fabs32 mo'_12712
                  let {cond_t_res_12718 : bool} =
                    lt32(1.0001f32, abs_res_12717)
                  let {x_12719 : bool} =
                    logand(x_12716, cond_t_res_12718)
                  let {fst_break_12720 : i32} =
                    if x_12719
                    then {i_12696} else {fst_break_12697}
                    : {i32}
                  let {tmp_12721 : f32} =
                    fadd32(mean_12698, mo'_12712)
                  in {fst_break_12720, tmp_12721, mo_12711}
                }
              let {cond_12722 : bool} =
                eq_i32(lifted_lambda_res_f_res_12693, -1i32)
              let {fst_break'_12723 : i32} =
                if cond_12722
                then {-1i32} else {
                  let {cond_12724 : bool} =
                    slt32(lifted_lambda_res_f_res_12693, upper_bound_12690)
                  let {adjustValInds_res_12725 : i32} =
                    if cond_12724
                    then {
                      let {-_lhs_12726 : i32} =
                        add32(lifted_lambda_res_f_res_12644, lifted_lambda_res_f_res_12693)
                      let {-_lhs_12727 : i64} =
                        sext i32 -_lhs_12726 to i64
                      let {-_lhs_12728 : i32} =
                        lifted_lambda_res_f_res_12647[-_lhs_12727]
                      let {adjustValInds_res_t_res_12729 : i32} =
                        sub32(-_lhs_12728, n_9439)
                      in {adjustValInds_res_t_res_12729}
                    } else {-1i32}
                    : {i32}
                  let {/_lhs_12730 : i32} =
                    sub32(adjustValInds_res_12725, 1i32)
                  let {*_lhs_12731 : i32} =
                    sdiv32(/_lhs_12730, 2i32)
                  let {+_lhs_12732 : i32} =
                    mul32(2i32, *_lhs_12731)
                  let {fst_break'_f_res_12733 : i32} =
                    add32(1i32, +_lhs_12732)
                  in {fst_break'_f_res_12733}
                }
                : {i32}
              let {cond_12734 : bool} =
                sle32(lifted_lambda_res_f_res_12644, 5i32)
              let {cond_f_res_12735 : bool} =
                sle32(upper_bound_12690, 5i32)
              let {x_12736 : bool} =
                not cond_12734
              let {y_12737 : bool} =
                logand(cond_f_res_12735, x_12736)
              let {cond_12738 : bool} =
                logor(cond_12734, y_12737)
              let {fst_break'_12739 : i32} =
                if cond_12738
                then {-2i32} else {fst_break'_12723}
                : {i32}
              in {fst_break'_12739, lifted_lambda_res_f_res_12694}
            }
            : {i32,
               f32}
          return {returns lifted_lambda_res_12541,
                  returns lifted_lambda_res_12542}
        }
      in {defunc_0_map_res_12534, defunc_0_map_res_12535}
    }
    : {[m_9436]i32,
       [m_9436]f32}
  in {defunc_0_map_res_11673, defunc_0_map_res_11674}
}


-- === Expected output after pass:
-- TBD
