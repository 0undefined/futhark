-- Random number generation inspired by <random> in C++.

import "/futlib/math"

-- Quick and dirty hashing to mix in something that looks like entropy.
-- From http://stackoverflow.com/a/12996028
local
let hash(x: i32): i32 =
  let x = ((x >>> 16) ^ x) * 0x45d9f3b
  let x = ((x >>> 16) ^ x) * 0x45d9f3b
  let x = ((x >>> 16) ^ x) in
  x

module type rng_engine = {
  -- | The type of values generated by the engine.
  type t
  -- | The state of the engine.
  type rng

  -- | Initialise an RNG state from a seed.  Even if the seed array is
  -- empty, the resulting RNG should still behave reasonably.  It is
  -- permissible for this function to process the seed array
  -- sequentially, so don't make it too large.
  val rng_from_seed: []i32 -> rng

  -- | Split an RNG state into several states.  Implementations of
  -- this function tend to be cryptographically unsound, so be
  -- careful.
  val split_rng: i32 -> rng -> []rng

  -- | Combine several RNG states into a single state - typically done
  -- with the result of 'split_rng'.
  val join_rng: []rng -> rng

  -- | Generate a single random element, and a new RNG state.
  val rand: rng -> (rng,t)

  -- | The minimum value potentially returned by the generator.
  val min: t

  -- | The maximum value potentially returned by the generator.
  val max: t
}

module type rng_distribution = {
  -- | The type of values produced by this random distribution.
  type t

  -- | The RNG engine state.
  type rng

  -- | The dynamic configuration of the distribution.
  type distribution

  val rand: distribution -> rng -> (rng, t)
}

module linear_congruential_engine (T: {
  type t
  val from_i32: i32 -> t
  val *: t -> t -> t
  val +: t -> t -> t
  val %%: t -> t -> t
  val ^: t -> t -> t
  val >>>: t -> t -> t
}) (P: {
  val a: T.t
  val c: T.t
  val m: T.t
}): rng_engine with t = T.t with rng = T.t = {
  type t = T.t
  type rng = t

  let rand (x: rng): (rng, t) =
    let rng' = (P.a T.* x T.+ P.c) T.%% P.m
    in (rng',rng')

  let rng_from_seed [n] (seed: [n]i32) =
    loop (seed' = T.from_i32 1) = for i < n do
      ((seed' T.>>> T.from_i32 16) T.^ seed') T.^
      T.from_i32 (seed[i] ^ 0b1010101010101)
    in #1 (rand seed')

  let split_rng (n: i32) (x: rng): [n]rng =
    map (\i -> x T.^ T.from_i32 (hash i)) (iota n)

  let join_rng [n] (xs: [n]rng): rng =
    reduce (T.^) (T.from_i32 0) xs

  let min = T.from_i32 0
  let max = P.m
}

-- | The xorshift128+ engine.  Use two 64-bit words as state.
module xorshift128plus_engine: rng_engine with t = u64 = {
  type t = u64
  type rng = (u64,u64)

  let rand ((x,y): rng): (rng, t) =
    let x = x ^ (x << 23u64)
    let new_x = y
    let new_y = x ^ y ^ (x >> 17u64) ^ (y >> 26u64)
    in ((new_x,new_y), new_y + y)

  let rng_from_seed [n] (seed: [n]i32) =
    loop (seed' = 1u64) = for i < n do
      ((seed' >>> 32u64) ^ seed') ^
      u64.from_i32 (seed[i] ^ 0b1010101010101)
    in #1 (rand (seed'>>>32u64, seed'))

  let split_rng (n: i32) ((x,y): rng): [n]rng =
    map (\i -> (x ^ u64.from_i32 (hash i),
                y ^ u64.from_i32 (hash i))) (iota n)

  let join_rng [n] (xs: [n]rng): rng =
    reduce (\(x1,y1) (x2,y2) -> (x1^x2,y1^y2)) (0u64,0u64) xs

  let min = 0u64
  let max = 0xFFFFFFFFFFFFFFFFu64
}

-- | A 'linear_congruential_engine' producing 'u32' values and
-- initialised with a=48271, c=u and m=2147483647.  This is the same
-- configuration as in C++.
module minstd_rand: rng_engine with t = u32 =
  linear_congruential_engine u32 {
    let a = 48271u32
    let c = 0u32
    let m = 2147483647u32
}

-- | A 'linear_congruential_engine' producing 'u32' values and
-- initialised with a=16807, c=u and m=2147483647.  This is the same
-- configuration as in C++.
module minstd_rand0: rng_engine with t = u32 =
  linear_congruential_engine u32 {
    let a = 16807u32
    let c = 0u32
    let m = 2147483647u32
}

module type convert = { type from type to val convert: from -> to}

module u32_to_f32 = {
  type from = u32
  type to = f32
  let convert (x: u32) = f32 x
}

module u32_to_f64 = {
  type from = u32
  type to = f64
  let convert (x: u32) = f64 x
}

module u32_to_i32 = {
  type from = u32
  type to = i32
  let convert (x: u32) = i32 x
}

-- | This uniform integer distribution generates integers in a given
-- range with equal probability for each.
module uniform_int_distribution
   (D: integral)
   (I: integral)
   (C: convert with from = I.t with to = D.t)
   (E: rng_engine with t = I.t):
  rng_distribution with t = D.t
                   with rng = E.rng
                   with distribution = (D.t,D.t) = {
  type t = D.t
  type rng = E.rng
  type distribution = (t,t) -- Lower and upper bounds.
  let uniform (min: t) (max: t) = (min,max)

  let rand ((min,max): distribution) (rng: E.rng) =
    let range = max D.- min D.+ D.from_i32 1
    in if range D.<= D.from_i32 0
       then (rng, C.convert E.min) -- Avoid infinite loop below.
       else let emax = C.convert E.max
            let secure_max = emax D.- emax D.% range
            loop ((rng, x) = E.rand rng) =
              while C.convert x D.>= secure_max do E.rand rng
            in (rng, min D.+ C.convert x D./ (secure_max D./ range))

}

-- | This uniform integer distribution generates floats in a given
-- range with "equal" probability for each.
module uniform_real_distribution
   (R: real)
   (I: integral)
   (C: convert with from = I.t with to = R.t)
   (E: rng_engine with t = I.t):
  rng_distribution with t = R.t
                   with rng = E.rng
                   with distribution = (R.t,R.t) = {
  type t = R.t
  type rng = E.rng
  type distribution = (t,t) -- Lower and upper bounds.
  let uniform (min: t) (max: t) = (min,max)
  let rand ((min,max): distribution) (rng: E.rng) =
    let (rng', x) = E.rand rng
    let x' = C.convert x R./ C.convert E.max
    in (rng', min R.+ x' R.* (max R.- min))
}

module normal_distribution
   (R: real)
   (I: integral)
   (C: convert with from = I.t with to = R.t)
   (E: rng_engine with t = I.t):
  rng_distribution with t = R.t
                   with rng = E.rng
                   with distribution = {mean:R.t,stddev:R.t} = {
  type t = R.t
  type rng = E.rng
  type distribution = {mean:t,stddev:t}

  let normal (mean: t) (stddev: t) = {mean=mean,stddev=stddev}

  open R

  let rand ({mean,stddev}: distribution) (rng: E.rng) =
    -- Box-Muller where we only use one of the generated points.
    let (rng, u1) = E.rand rng
    let (rng, u2) = E.rand rng
    let u1 = C.convert u1 R./ C.convert E.max
    let u2 = C.convert u2 R./ C.convert E.max
    let r = R.sqrt (R.from_i32 (-2) R.* R.log u1)
    let theta = R.from_i32 2 R.* R.pi R.* u2
    in (rng, mean + stddev R.* (r R.* R.cos theta))
}
