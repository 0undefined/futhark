                       Bohrium Backend for L0

         Troels Blum, Martin Dybdal, Martin Elsman, Troels Henriksen,
         Simon Lund, Kenneth Skovhede

                 Sophienberg, December 2013


* L0

* Bohrium

* L0-rewriting

    - Loop fission

        map (fn row => red(op +,0,row) / m, a)   ==>
          let t = map (fn row => red(op +, 0, row), a)
          in map (fn e => e / m, t)

    - Horizontal fission

        (xs,ys) = unzip(red(fn ((accMax,accMin),x) => (max accMax x, 
                                                       min accMin x),
                            a)) ==> 

        xs = red (fn (accMax,x) => max accMax x, a)
        ys = red (fn (accMin,x) => min accMin x, a)

    - Branching -> bitmasks

        map (fn x => if x > c then f x else g x, a)   ==>
       
        mask = map (fn x => x > c, a) 
        fxs = map (f,a)
        gxs = map (g,a)
        map (fn (m,x,y) => x * m + y * not m, mask, fxs, gxs)

    - reduce(map) -> map(reduce)

* Modify C code generator

    - Recognize L0-patterns

* Test programs

* "Formalization"


